import JSON;

/**
 * Provides static methods to compare two ActionScript objects and to apply
 * the resulting difference to an object.
 */
class JSONDiff {

    /**
     * Private constructor to prevent instantiation of this static utility class.
     */
    private function JSONDiff() {}

    // =================================================================================
    //  Public API Methods
    // =================================================================================

    /**
     * Compares two objects and returns an object detailing what was added, removed, and edited.
     *
     * @param   e               The original object.
     * @param   n               The new object.
     * @param   isLodashLike    (Optional) A boolean to format paths like lodash (e.g., 'a[0].b'). Defaults to slash-based paths ('a/0/b').
     * @return  An object with 'added', 'removed', and 'edited' arrays detailing the differences.
     */
    public static function getDiff(e:Object, n:Object, isLodashLike:Boolean):Object {
        if (isLodashLike == undefined) { isLodashLike = false; }
        var diff:Object = { added: [], removed: [], edited: [] };
        var s:Object = JSONDiff._getStructPath(e, isLodashLike);
        var y:Object = JSONDiff._getStructPath(n, isLodashLike);
        diff.removed = JSONDiff._getPathsDiff(s, y);
        diff.added = JSONDiff._getPathsDiff(y, s);
        diff.edited = JSONDiff._getEditedPaths(s, y);
        return JSONDiff._N(diff);
    }

    /**
     * Applies a diff object (generated by getDiff) to a source object.
     * This method is non-destructive; it returns a new, modified object.
     *
     * @param   source  The object to which the diff will be applied.
     * @param   diff    The diff object created by the getDiff method.
     * @return  A new object with the differences applied.
     */
    public static function applyDiff(source:Object, diff:Object):Object {
        if (diff == null || typeof(diff) != "object") {
            return source; // Return original if diff is invalid.
        }

        // Create a deep copy of the source object to avoid modifying the original.
        var newObj:Object = JSON.parse(JSON.stringify(source));

        // --- Handle Removals ---
        var removed:Array = diff.removed || [];
        for (var i:Number = 0; i < removed.length; i++) {
            var path:String = removed[i][0];
            JSONDiff._deletePropertyByPath(newObj, path);
        }

        // --- Handle Additions ---
        var added:Array = diff.added || [];
        for (var i:Number = 0; i < added.length; i++) {
            var path:String = added[i][0];
            var value:Object = added[i][1];
            JSONDiff._setPropertyByPath(newObj, path, value);
        }

        // --- Handle Edits ---
        var edited:Array = diff.edited || [];
        for (var i:Number = 0; i < edited.length; i++) {
            var path:String = edited[i][0];
            var value:Object = edited[i][2]; // Use the new value

            // Handle the special case where the root object itself is replaced.
            if (path === "__root__") {
                newObj = value;
            } else {
                JSONDiff._setPropertyByPath(newObj, path, value);
            }
        }

        return newObj;
    }

    /**
     * Directly modifies an object by setting a new value at a given path
     * AND returns the diff object representing that change.
     * This function has a side effect: it mutates the sourceObject.
     * @param   path          The path to the property to change.
     * @param   newValue      The new value for the property.
     * @param   sourceObject  The state object to read from AND modify.
     * @return  A valid DiffObject representing the change.
     */
    public static function updateAndGetDiff(sourceObject:Object, path:String, newValue:Object):Object {
        // 1. Read the old value before making any changes.
        var oldValue:Object = JSONDiff._getValueByPath(sourceObject, path);

        // 2. Enact the change by directly modifying the source object.
        JSONDiff._setPropertyByPath(sourceObject, path, newValue);

        // 3. Create the diff based on the old and new values.
        var diff:Object = { added: [], removed: [], edited: [] };

        if (oldValue == undefined) {
            // If the old value didn't exist, this is an "add".
            diff.added.push([path, newValue]);
        } else if (JSON.stringify(oldValue) !== JSON.stringify(newValue)) {
            // If the old value existed and is different, this is an "edit".
            diff.edited.push([path, oldValue, newValue]);
        }
        
        return diff;
    }

    /**
     * Merges two diff objects into a single diff. If both diffs edit the
     * same path, the change from the second diff ('diff2') is kept.
     *
     * @param   diff1   The base diff object.
     * @param   diff2   The diff object to merge, which takes precedence.
     * @return  A new, single diff object containing the merged changes.
     */
    public static function mergeDataDiff(diff1:Object, diff2:Object):Object {
        // Use a standard Object as a map to handle edited paths.
        var editedMap:Object = new Object();
        var i:Number;

        // Process the first diff's edits.
        for (i = 0; i < diff1.edited.length; i++) {
            var item1:Array = diff1.edited[i];
            var path1:String = item1[0];
            editedMap[path1] = item1;
        }

        // Process the second diff's edits, which will overwrite any duplicates.
        for (i = 0; i < diff2.edited.length; i++) {
            var item2:Array = diff2.edited[i];
            var path2:String = item2[0];
            editedMap[path2] = item2;
        }

        // Convert the map object back into an array.
        var finalEdited:Array = new Array();
        for (var key:String in editedMap) {
            finalEdited.push(editedMap[key]);
        }
        
        // Combine all changes into the final diff object.
        var finalDiff:Object = {
            added: diff1.added.concat(diff2.added),
            removed: diff1.removed.concat(diff2.removed),
            edited: finalEdited
        };

        return finalDiff;
    }

    // =================================================================================
    //  Internal Helper Methods
    // =================================================================================
    
    /**
     * [INTERNAL] Sets a property on an object using a path string.
     * Creates nested objects/arrays as needed.
     */
    private static function _setPropertyByPath(obj:Object, path:String, value:Object):Void {
        Main.trace('_setPropertyByPath: ' + path + ' = ' + JSON.stringify(value));
        // -- CORRECTION: Replaced regex with AS2-compatible split/join. --
        var tempPath:String = path.split('[').join('/'); // a[0] -> a/0]
        tempPath = tempPath.split(']').join('');         // a/0] -> a/0
        var segments:Array = tempPath.split('/');

        var current:Object = obj;

        for (var i:Number = 0; i < segments.length - 1; i++) {
            var key:String = segments[i];
            if (current[key] == undefined) {
                // If the next key is a number, create an Array, otherwise create an Object.
                var nextKey:String = segments[i + 1];
                if (String(Number(nextKey)) == nextKey) { // Check if it's a numeric index
                    current[key] = new Array();
                } else {
                    current[key] = new Object();
                }
            }
            current = current[key];
        }

        Main.trace(path + ': ' + JSON.stringify(current[segments[segments.length - 1]]) + ' -> ' + JSON.stringify(value));
        current[segments[segments.length - 1]] = value;

        Main.trace(JSON.stringify(obj.assets[0].groups[0].requirements[0]));
    }

    /**
     * [INTERNAL] Deletes a property from an object using a path string.
     * UPDATED: Uses splice() for arrays to correctly handle element removal.
     */
    private static function _deletePropertyByPath(obj:Object, path:String):Void {
        var tempPath:String = path.split('[').join('/');
        tempPath = tempPath.split(']').join('');
        var segments:Array = tempPath.split('/');
        
        var current:Object = obj;

        for (var i:Number = 0; i < segments.length - 1; i++) {
            var key:String = segments[i];
            if (current[key] == undefined) {
                return; // Path doesn't exist, nothing to delete.
            }
            current = current[key];
        }

        var finalKey:String = segments[segments.length - 1];

        if (current instanceof Array) {
            // Use splice() to correctly remove the element and shorten the array.
            current.splice(Number(finalKey), 1);
        } else {
            // Use delete for regular object properties.
            delete current[finalKey];
        }
    }

    /**
     * [INTERNAL] Normalizes the final diff object, converting placeholders like '@{}'
     * back into empty objects and arrays.
     */
    private static function _N(diff:Object):Object {
        var originalEdited:Array = diff.edited;
        var filteredEdited:Array = new Array();
        for (var i:Number = 0; i < originalEdited.length; i++) {
            var item:Array = originalEdited[i];
            if (typeof(item[1]) == "object" && item[2] === "@{}") { continue; }
            if (item[2] === "@{}") { item[2] = new Object(); } 
            else if (item[2] === "@[]") { item[2] = new Array(); }
            filteredEdited.push(item);
        }
        diff.edited = filteredEdited;
        return diff;
    }

    /**
     * [INTERNAL] Finds paths that exist in the first object but not the second.
     */
    private static function _getPathsDiff(e:Object, n:Object):Array {
        var diff:Array = new Array();
        for (var i:String in e) {
            if (n[i] == undefined) {
                var val:Object = e[i];
                if (e[i] === "@{}") { val = new Object(); } 
                else if (e[i] === "@[]") { val = new Array(); }
                diff.push([i, val]);
            }
        }
        return diff;
    }

    /**
     * [INTERNAL] Finds paths that exist in both objects but have different values.
     */
    private static function _getEditedPaths(e:Object, n:Object):Array {
        var o:Array = new Array();
        for (var f:String in e) {
            if (n[f] != undefined) {
                var valE:Object = e[f];
                var valN:Object = n[f];
                var isObjects:Boolean = (typeof(valE) == "object" && typeof(valN) == "object");
                if ((isObjects && JSON.stringify(valE) === JSON.stringify(valN)) || (valE === valN)) {
                    continue;
                }
                if (valE === '@{}' || valE === '@[]') {
                    var i:Object = (valN === '@{}') ? new Object() : (valN === '@[]') ? new Array() : valN;
                    if (valE === '@{}') {
                        if (JSON.stringify(valN) !== '{}') { o.push([f, new Object(), i]); }
                    } else {
                        if (JSON.stringify(valN) !== '[]') { o.push([f, new Array(), i]); }
                    }
                } else {
                    o.push([f, valE, valN]);
                }
            }
        }
        return o;
    }
    
    /**
     * [INTERNAL] Recursively flattens a JSON object into a path-based key-value map.
     */
    private static function _getStructPath(e:Object, isLodashLike:Boolean, o:Object, f:String):Object {
        if (o == undefined) { o = (e instanceof Array) ? { __root__: '@[]' } : { __root__: '@{}' }; }
        if (f == undefined) { f = "__start__"; }
        for (var i:String in e) {
            var r:String = JSONDiff._c(e instanceof Array, f, i, isLodashLike);
            var val:Object = e[i];
            if (val !== null && typeof(val) == "object") {
                var keyCount:Number = 0;
                for (var k:String in val) { keyCount++; }
                if (keyCount === 0) {
                    o[r] = val;
                } else {
                    o[r] = (val instanceof Array) ? '@[]' : '@{}';
                    JSONDiff._getStructPath(val, isLodashLike, o, r);
                }
            } else {
                o[r] = val;
            }
        }
        return o;
    }

    /**
     * [INTERNAL] Helper function to construct path strings (e.g., 'parent/child' or 'parent.child').
     */
    private static function _c(isArray:Boolean, parentPath:String, key:String, isLodashLike:Boolean):String {
        var separator:String = isLodashLike ? (isArray ? "" : ".") : "/";
        var prefix:String = isLodashLike ? (isArray ? "[" : "") : "";
        var suffix:String = isLodashLike ? "]" : "";
        if (parentPath === "__start__") {
            return (isLodashLike && isArray) ? "[" + key + "]" : key;
        } else {
            return parentPath + (isLodashLike && !isArray ? separator : "") + prefix + key + suffix;
        }
    }

    /**
     * [INTERNAL HELPER] Traverses an object using a path string and returns the value.
     * Returns undefined if the path does not exist.
     */
    private static function _getValueByPath(obj:Object, path:String):Object {
        // Use the same path parsing as _setPropertyByPath to handle formats like 'a[0]/b'
        var tempPath:String = path.split('[').join('/');
        tempPath = tempPath.split(']').join('');
        var keys:Array = tempPath.split('/');

        var current:Object = obj;
        
        for (var i:Number = 0; i < keys.length; i++) {
            if (current == undefined || current == null) {
                return undefined;
            }
            var key:String = keys[i];
            current = current[key];
        }
        
        return current;
    }
}