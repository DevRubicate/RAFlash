import JSON;

/**
 * Provides static methods to compare two ActionScript objects and to apply
 * the resulting difference to an object.
 */
class JSONDiff {

    /**
     * Private constructor to prevent instantiation of this static utility class.
     */
    private function JSONDiff() {}

    // =================================================================================
    //  Public API Methods
    // =================================================================================

    /**
     * Compares two objects and returns an object detailing what was added, removed, and edited.
     *
     * @param   e               The original object.
     * @param   n               The new object.
     * @param   isLodashLike    (Optional) A boolean to format paths like lodash (e.g., 'a[0].b'). Defaults to slash-based paths ('a/0/b').
     * @return  An object with 'added', 'removed', and 'edited' arrays detailing the differences.
     */
    public static function getDiff(e:Object, n:Object, isLodashLike:Boolean):Object {
        if (isLodashLike == undefined) { isLodashLike = false; }
        var diff:Object = { added: [], removed: [], edited: [] };
        var s:Object = JSONDiff._getStructPath(e, isLodashLike);
        var y:Object = JSONDiff._getStructPath(n, isLodashLike);
        diff.removed = JSONDiff._getPathsDiff(s, y);
        diff.added = JSONDiff._getPathsDiff(y, s);
        diff.edited = JSONDiff._getEditedPaths(s, y);
        return JSONDiff._N(diff);
    }

    /**
     * Applies a diff object (generated by getDiff) to a source object.
     * This method is non-destructive; it returns a new, modified object.
     *
     * @param   source  The object to which the diff will be applied.
     * @param   diff    The diff object created by the getDiff method.
     * @return  A new object with the differences applied.
     */
    public static function applyDiff(source:Object, diff:Object):Object {
        if (diff == null || typeof(diff) != "object") {
            return source; // Return original if diff is invalid.
        }

        // Create a deep copy of the source object to avoid modifying the original.
        var newObj:Object = JSON.parse(JSON.stringify(source));

        // --- Handle Removals ---
        var removed:Array = diff.removed || [];
        for (var i:Number = 0; i < removed.length; i++) {
            var path:String = removed[i][0];
            JSONDiff._deletePropertyByPath(newObj, path);
        }

        // --- Handle Additions ---
        var added:Array = diff.added || [];
        for (var i:Number = 0; i < added.length; i++) {
            var path:String = added[i][0];
            var value:Object = added[i][1];
            JSONDiff._setPropertyByPath(newObj, path, value);
        }

        // --- Handle Edits ---
        var edited:Array = diff.edited || [];
        for (var i:Number = 0; i < edited.length; i++) {
            var path:String = edited[i][0];
            var value:Object = edited[i][2]; // Use the new value

            // Handle the special case where the root object itself is replaced.
            if (path === "__root__") {
                newObj = value;
            } else {
                JSONDiff._setPropertyByPath(newObj, path, value);
            }
        }

        return newObj;
    }

    // =================================================================================
    //  Internal Helper Methods
    // =================================================================================
    
    /**
     * [INTERNAL] Sets a property on an object using a path string.
     * Creates nested objects/arrays as needed.
     */
    private static function _setPropertyByPath(obj:Object, path:String, value:Object):Void {
        // -- CORRECTION: Replaced regex with AS2-compatible split/join. --
        var tempPath:String = path.split('[').join('/'); // a[0] -> a/0]
        tempPath = tempPath.split(']').join('');         // a/0] -> a/0
        var segments:Array = tempPath.split('/');

        var current:Object = obj;

        for (var i:Number = 0; i < segments.length - 1; i++) {
            var key:String = segments[i];
            if (current[key] == undefined) {
                // If the next key is a number, create an Array, otherwise create an Object.
                var nextKey:String = segments[i + 1];
                if (String(Number(nextKey)) == nextKey) { // Check if it's a numeric index
                    current[key] = new Array();
                } else {
                    current[key] = new Object();
                }
            }
            current = current[key];
        }

        current[segments[segments.length - 1]] = value;
    }

    /**
     * [INTERNAL] Deletes a property from an object using a path string.
     */
    private static function _deletePropertyByPath(obj:Object, path:String):Void {
        // -- CORRECTION: Replaced regex with AS2-compatible split/join. --
        var tempPath:String = path.split('[').join('/');
        tempPath = tempPath.split(']').join('');
        var segments:Array = tempPath.split('/');
        
        var current:Object = obj;

        for (var i:Number = 0; i < segments.length - 1; i++) {
            var key:String = segments[i];
            if (current[key] == undefined) {
                return; // Path doesn't exist, nothing to delete.
            }
            current = current[key];
        }

        delete current[segments[segments.length - 1]];
    }

    /**
     * [INTERNAL] Normalizes the final diff object, converting placeholders like '@{}'
     * back into empty objects and arrays.
     */
    private static function _N(diff:Object):Object {
        var originalEdited:Array = diff.edited;
        var filteredEdited:Array = new Array();
        for (var i:Number = 0; i < originalEdited.length; i++) {
            var item:Array = originalEdited[i];
            if (typeof(item[1]) == "object" && item[2] === "@{}") { continue; }
            if (item[2] === "@{}") { item[2] = new Object(); } 
            else if (item[2] === "@[]") { item[2] = new Array(); }
            filteredEdited.push(item);
        }
        diff.edited = filteredEdited;
        return diff;
    }

    /**
     * [INTERNAL] Finds paths that exist in the first object but not the second.
     */
    private static function _getPathsDiff(e:Object, n:Object):Array {
        var diff:Array = new Array();
        for (var i:String in e) {
            if (n[i] == undefined) {
                var val:Object = e[i];
                if (e[i] === "@{}") { val = new Object(); } 
                else if (e[i] === "@[]") { val = new Array(); }
                diff.push([i, val]);
            }
        }
        return diff;
    }

    /**
     * [INTERNAL] Finds paths that exist in both objects but have different values.
     */
    private static function _getEditedPaths(e:Object, n:Object):Array {
        var o:Array = new Array();
        for (var f:String in e) {
            if (n[f] != undefined) {
                var valE:Object = e[f];
                var valN:Object = n[f];
                var isObjects:Boolean = (typeof(valE) == "object" && typeof(valN) == "object");
                if ((isObjects && JSON.stringify(valE) === JSON.stringify(valN)) || (valE === valN)) {
                    continue;
                }
                if (valE === '@{}' || valE === '@[]') {
                    var i:Object = (valN === '@{}') ? new Object() : (valN === '@[]') ? new Array() : valN;
                    if (valE === '@{}') {
                        if (JSON.stringify(valN) !== '{}') { o.push([f, new Object(), i]); }
                    } else {
                        if (JSON.stringify(valN) !== '[]') { o.push([f, new Array(), i]); }
                    }
                } else {
                    o.push([f, valE, valN]);
                }
            }
        }
        return o;
    }
    
    /**
     * [INTERNAL] Recursively flattens a JSON object into a path-based key-value map.
     */
    private static function _getStructPath(e:Object, isLodashLike:Boolean, o:Object, f:String):Object {
        if (o == undefined) { o = (e instanceof Array) ? { __root__: '@[]' } : { __root__: '@{}' }; }
        if (f == undefined) { f = "__start__"; }
        for (var i:String in e) {
            var r:String = JSONDiff._c(e instanceof Array, f, i, isLodashLike);
            var val:Object = e[i];
            if (val !== null && typeof(val) == "object") {
                var keyCount:Number = 0;
                for (var k:String in val) { keyCount++; }
                if (keyCount === 0) {
                    o[r] = val;
                } else {
                    o[r] = (val instanceof Array) ? '@[]' : '@{}';
                    JSONDiff._getStructPath(val, isLodashLike, o, r);
                }
            } else {
                o[r] = val;
            }
        }
        return o;
    }

    /**
     * [INTERNAL] Helper function to construct path strings (e.g., 'parent/child' or 'parent.child').
     */
    private static function _c(isArray:Boolean, parentPath:String, key:String, isLodashLike:Boolean):String {
        var separator:String = isLodashLike ? (isArray ? "" : ".") : "/";
        var prefix:String = isLodashLike ? (isArray ? "[" : "") : "";
        var suffix:String = isLodashLike ? "]" : "";
        if (parentPath === "__start__") {
            return (isLodashLike && isArray) ? "[" + key + "]" : key;
        } else {
            return parentPath + (isLodashLike && !isArray ? separator : "") + prefix + key + suffix;
        }
    }
}